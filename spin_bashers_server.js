// Generated by CoffeeScript 1.3.3
(function() {
  var Arena, Game, Player, PlayerPhysics, UUID, V, Vector, arena_body_def, arena_edge_fixtures, arena_size, b2d, base_game, constraint_iterations, crate_body_def, crate_diameter, crate_fixture_def, crate_shape_def, crate_type, damaging_impulse, default_color, default_friction, default_size, do_sleep, edge, fixture_def, force, force_angle, frame_rate, gravity, half_player_distance, index, make_arena, make_crate, make_damped_body_def, make_players, max_angular_velocity, origin, player1_position, player2_position, player_distance, player_fixture_def, player_friction, player_radius, player_shape_def, player_type, players_body_def, point1, point2, time_step, torque, use_joint, world_padding, world_size, _, _i, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  b2d = require('box2dnode');

  _ref = require('./server_box2d_vector'), V = _ref.V, Vector = _ref.Vector;

  b2d.b2Vec2 = Vector;

  frame_rate = require('./frame_rate');

  _ = require('underscore');

  UUID = require('./library/uuid').UUID;

  base_game = require('./base_game');

  origin = V(0, 0);

  _ref1 = [0, 1], player_type = _ref1[0], crate_type = _ref1[1];

  use_joint = true;

  time_step = 1.0 / 60.0;

  constraint_iterations = 10;

  gravity = V(0.0, -10.0);

  player_friction = 20;

  default_friction = 5;

  torque = 50;

  max_angular_velocity = 10;

  default_size = V(1, 1);

  default_color = 0xff0000;

  damaging_impulse = 2;

  force = 25;

  force_angle = 45;

  do_sleep = true;

  world_size = V(2000, 2000);

  world_padding = 50;

  gravity = origin;

  player_radius = 1;

  player_shape_def = new b2d.b2CircleShape(player_radius);

  players_body_def = new b2d.b2BodyDef;

  players_body_def.type = b2d.b2Body.b2_dynamicBody;

  players_body_def.linearDamping = 1;

  player_fixture_def = new b2d.b2FixtureDef;

  player_fixture_def.shape = player_shape_def;

  player_fixture_def.density = 1.0;

  player_fixture_def.restitution = 1.0;

  player_distance = 6;

  half_player_distance = player_distance / 2;

  player1_position = V(-half_player_distance, 0);

  player2_position = V(half_player_distance, 0);

  make_players = function(world, position) {
    var body, fixture1, fixture2;
    players_body_def.position = position;
    body = world.CreateBody(players_body_def);
    player_shape_def.SetLocalPosition(player1_position);
    fixture1 = body.CreateFixture(player_fixture_def);
    player_shape_def.SetLocalPosition(player2_position);
    fixture2 = body.CreateFixture(player_fixture_def);
    return {
      player1: fixture1,
      player2: fixture2,
      body: body
    };
  };

  make_damped_body_def = function() {
    var def;
    def = new b2d.b2BodyDef;
    def.type = b2d.b2Body.b2_dynamicBody;
    def.linearDamping = 1;
    def.angularDamping = 1;
    return def;
  };

  crate_diameter = 2;

  crate_shape_def = new b2d.b2PolygonShape;

  crate_shape_def.SetAsBox(crate_diameter, crate_diameter);

  crate_body_def = make_damped_body_def();

  crate_fixture_def = new b2d.b2FixtureDef;

  crate_fixture_def.shape = crate_shape_def;

  crate_fixture_def.density = 1.0;

  crate_fixture_def.restitution = 1.0;

  make_crate = function(world, position) {
    var body, fixture;
    crate_body_def.position = position;
    body = world.CreateBody(crate_body_def);
    fixture = body.CreateFixture(crate_fixture);
    return fixture;
  };

  arena_size = 10;

  arena_edge_fixtures = [];

  for (index = _i = 0, _ref2 = base_game.diagonals.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; index = 0 <= _ref2 ? ++_i : --_i) {
    point1 = base_game.diagonals[index];
    point2 = base_game.diagonals[(index + 1) % base_game.diagonals.length];
    edge = new b2d.b2EdgeShape(point1, point2);
    fixture_def = new b2d.b2FixtureDef;
    fixture_def.shape = edge;
    arena_edge_fixtures.push;
  }

  arena_body_def = new b2d.b2BodyDef;

  arena_body_def.type = b2d.b2Body.b2_staticBody;

  make_arena = function(world) {
    var body, fixture, _j, _len;
    body = world.CreateBody(arena_body_def);
    for (_j = 0, _len = arena_edge_fixtures.length; _j < _len; _j++) {
      fixture = arena_edge_fixtures[_j];
      body.CreateFixture(fixture);
    }
    return body;
  };

  Arena = (function(_super) {

    __extends(Arena, _super);

    function Arena() {
      return Arena.__super__.constructor.apply(this, arguments);
    }

    Arena.prototype.type = 'arena';

    Arena.prototype.setup = function() {
      this.body = make_arena(this.game.world);
      return this.size = V(arena_size, arena_size);
    };

    return Arena;

  })(base_game.AbstractBody);

  PlayerPhysics = (function(_super) {

    __extends(PlayerPhysics, _super);

    function PlayerPhysics() {
      return PlayerPhysics.__super__.constructor.apply(this, arguments);
    }

    PlayerPhysics.prototype.type = 'player';

    PlayerPhysics.prototype.setup = function() {
      var _ref3;
      _ref3 = make_players(this.game.world, origin), this.player1 = _ref3.player1, this.player2 = _ref3.player2, this.body = _ref3.body;
      return this.size = V(8, 8);
    };

    return PlayerPhysics;

  })(base_game.AbstractBody);

  Player = (function(_super) {

    __extends(Player, _super);

    function Player(args) {
      this.shape = args.shape;
      Player.__super__.constructor.call(this, args);
    }

    Player.prototype.control = function() {};

    return Player;

  })(base_game.AbstractPlayer);

  Game = (function(_super) {

    __extends(Game, _super);

    function Game(args, sockets, id) {
      this.challenger = args.challenger, this.challengee = args.challengee;
      Game.__super__.constructor.call(this, sockets, id);
      this.challenger.socket.join(this.channel);
      this.challengee.socket.join(this.channel);
      this.challenger.socket.emit('start_game', this);
      this.challengee.socket.emit('start_game', this);
    }

    Game.prototype.setup = function() {
      this.world = new b2d.b2World(gravity, true);
      this.arena = new Arena(this);
      this.player_body = new PlayerPhysics(this);
      this.player1 = new Player({
        game: this,
        user: this.challenger,
        shape: this.player_body.player1
      });
      return this.player2 = new Player({
        game: this,
        user: this.challengee,
        shape: this.player_body.player2
      });
    };

    Game.prototype.control_players = function() {
      var body_angle, body_position, command, direction, player1_offset, player2_offset, _ref3, _results;
      body_position = this.player_body.get_position();
      body_angle = this.player_body.get_angle();
      player1_offset = (V(0, half_player_distance)).rotate(body_angle);
      player2_offset = player1_offset.rotate(Math.PI);
      player1_position = body_position.plus(player1_offset);
      player2_position = body_position.plus(player2_offset);
      _ref3 = base_game.cardinals;
      _results = [];
      for (command in _ref3) {
        direction = _ref3[command];
        if (this.player1.commands[command]) {
          this.player_body.body.ApplyForce(direction.scale(force), player1_position);
        }
        if (this.player2.commands[command]) {
          _results.push(this.player_body.body.ApplyForce(direction.scale(force), player2_position));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
      /*
              player1_position = player1.body.body.GetPosition()
              player2_position = player2.body.body.GetPosition()
              player1_direction = player2_position.minus(player1_position).normalize()
              center = player1_position.plus player2_position.minus(player1_position).scale(0.5)
      
              player1_clockwise = player1.commands.clockwise or false
              player2_clockwise = player2.commands.clockwise or false
              player1_counter_clockwise = player1.commands.counter_clockwise or false
              player2_counter_clockwise = player2.commands.counter_clockwise or false
      
      
              player1_rotation_commitment = if player1_clockwise is player1_counter_clockwise then 0 else if player1_clockwise then 1 else -1
              player2_rotation_commitment = if player2_clockwise is player2_counter_clockwise then 0 else if player2_clockwise then 1 else -1
      
              if player1_rotation_commitment isnt -player2_rotation_commitment
                  if player1_rotation_commitment isnt 0
                      force_direction = player1_direction.scale(-1).rotate force_angle * player1_rotation_commitment
                      player2.body.body.ApplyForce force_direction.scale(force), player2_position
                  
                  if player2_rotation_commitment isnt 0
                      force_direction2 = player1_direction.rotate force_angle * player2_rotation_commitment
                      player1.body.body.ApplyForce force_direction2.scale(force), player1_position
      */

    };

    Game.prototype.teardown = function() {
      return this.player_body.remove();
    };

    return Game;

  })(base_game.AbstractGame);

  /*
  
  get_type = (shape) -> shape.GetBody().GetUserData().type
  get_data = (shape) -> shape.GetBody().GetUserData()
  
  # contact listener
  contact_listener = new b2ContactListener()
  contact_listener.Result = (contact) ->
      if contact.normalImpulse > damaging_impulse
          shapes = [contact.shape1, contact.shape2]
          shapes.sort (a,b) -> get_type(a) - get_type(b)
          type1 = get_type shapes[0]
          type2 = get_type shapes[1]
  
          if type1 is player_type and type2 is crate_type
              player_data = get_data contact.shape1
              player = if player_data.which is 1 then player1 else player2
              hurt_player(player, contact.normalImpulse)
  
  world.SetContactListener contact_listener
  
  player1 = make_square
      position:V(-2, 2)
      color:0x0000ff
      data:
          type:player_type
          which:1
  player2 = make_square
      position:V(2, -2)
      data:
          type:player_type
          which:2
  
  player1.hit_points = player2.hit_points = 100
  player1.name = "Blue Player"
  player2.name = "Red Player"
  player1.which = 1
  player2.which = 2
  
  players = [player1, player2]
  other_player = (player) ->
      if player is players[0] then players[1] else players[0]
  
  if use_joint
      joint_definition = new b2DistanceJointDef()
      joint_definition.Initialize player1.body, player2.body,
          player1.body.GetPosition(), player2.body.GetPosition()
      joint = world.CreateJoint joint_definition
  
  make_heap = (location) ->
      size = 1
      elevation = 3
      for index in [0..10]
          make_square
              position:V(location, index*2)
  
  make_level = ->
      make_heap 2
  
  hurt_player = (player, damage) ->
      player.hit_points -= damage
      #console.log "#{player.name} was hit for #{damage}. #{player.hit_points} HP remaining. #{Date()}"
      $("#player#{player.which}_hit_points").text Math.round player.hit_points
      if player.hit_points < 0
          winner = other_player player
          game_over = true
          #console.log "#{winner.name} wins!"
          $("#winner").text("#{winner.name} wins!").addClass("player#{winner.which}")
  */


  exports.Game = Game;

}).call(this);
